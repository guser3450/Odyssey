"include "\0" at the end"
INIT User_floor[11]


"elevator_list"
INIT Elevator_list[2]
FOR EACH Elevator ADD 1 action_list


"the list to know if elevators are doing something or not"
Floor_list 

elevator stop 


"the floor were the user as the choice to go UP or DOWN"
INIT User_floor[11]
    ADD Button FOR EACH User_floor[i]
    FOR EACH Button OUTPUT print(Up) AND print(Down)
    FOR EACH Up AND Down Button IS define By Number(1++)
    UNTIL END of Button[i]
    1 <-- RC 


"this pointer does not change array. It only transport information form the user INPUT FROM Floor[1] (An ARRAY to An other)"
POINTER <-- Elevator  


"the floor were the user is IN the elevator with the choice of witch floors he wants to go"
INIT Storeys[i]


Storeys[i] EQUALS User_floor[i]
    //pointer
    ADD Elevator
    FOR EACH Storeys[i] ADD Button AND print(Storeys[i])



//              SEQUENCE             \\


"operate see the elevator list is empty or not and add a call to the choices elevator"
SEQUENCE operator USING elevator AND floor
    ADD floor to  Elevator_floor_list
    CALL move


    // ADD request_elevator() INPUT TO action_list
    // IF(action_list[i] of elevator[i] EQUALS NULL THEN)
    //     RETURN Elevator
    // ELSE IF(action_list[i] of elevator[i] IS NOT EQUALS TO NULL THEN)
    //     ADD move() TO action_list 
ENDSEQUENCE


" 1 STEP: Button on the colonne(up, down) so request_elevator is dependente to find_elevator and find_elevator depend on request_elevator"
"???EST-CE QUE JE DOIS ABSULUMENT RENDRE MES 2 SEQUENCES DEPENDENTE UNE DE LAUTRE???"
SEQUENCE request_elevator USING floor AND direction
    CALL find_elevator USING floor AND direction
    CALL operator USING Elevator AND Button
    




    // FOR EACH Button INPUT IN User_floor[i]
    //     IF(Button UP IS click)
    //         RETURN direction Up AND 
    //     ELSE IF(Button Down IS click)
    //         RETURN direction Down
    //     operate elevator, ajoute a lsite, 
    // ENDFOR        
ENDSEQUENCE


SEQUENCE Open_door 
    SPEED <-- 10 sec 
        Return open door for SPEED
ENDSEQUENCE


SEQUENCE Close_door()
    if(obstacle == true)
        RETURN Open_door()
    else()
        RETURN Open_door()
ENDSEQUENCE


"In this SEQUENCE I tell the elevator to use the floor_list to go up and down and I add some condition to max the quantity of people in the elevator"
SEQUENCE move USING Elevator AND floor_list 
WHILE floor_list is NOT empty 
    FOR EACH input_elevator
    IF Elevator_Floor IS greater TO floor_List THEN
        MoveDown AND REPEAT UNTIL elevator_floor IS EQUALS TO floor_list THEN
        STOP AND Open_door

    IF Elevator_Floor IS smaller TO floor_List THEN 
        MoveUp AND REPEAT UNTIL elevator_floor IS EQUALS TO floor_list THEN
        STOP AND Open_door

    IF Floor_list IS NOT EQUALS TO NULL THEN 
        ADD the new request_elevator at the END OF the floor_list 
        IF floor_list containt MoveUp AND the new request_elevator IS Up THEN 
            ADD the new request_elevator TO the top OF floor_list 

        IF floor_list containt MoveDown AND the new request_elevator IS Down THEN
            ADD the new request_elevator TO the top OF floor_list
    ENDFOR
ENDWHILE

WHILE floor_list IS empty
    FOR EACH request_elevator
    IF request_elevator IS Up THEN 
        ADD TO floor_list
    IF request_elevator IS Down THEN
        ADD TO floor_list
    ENDFOR
ENDWHILE
    
ENDSEQUENCE


SEQUENCE find_elevator USING user_floor AND user_direction AND elevator_floor AND elevator_direction AND elevator_stop

   INIT bestCase_list
    IF elevator EQUALS Priority THEN
        SET elevator_gap to user_floor MINUS elevator_floor
        RETURN elevator 


    IF elevator_floor EQUALS user_floor AND elevator IS stop
    assigne to priority 1

    IF elevator_floor IS greater TO user_floor AND elevator IS stop OR elevator_floor IS smaller TO user_floor AND elevator IS stop THEN 
        assigne to priority 2 

    IF elevator_floor IS greater TO user_floor AND elevator_direction EQUALS user_direction OR elevator_floor IS smaller TO user_floor AND elevator_direction EQUALS user_direction THEN
        assigne to priority 3

    IF elevator_floor IS greater TO user_floor AND elevator_direction IS NOT EQUALS TO user_direction OR elevator_floor IS smaller TO user_floor AND elevator_direction IS NOT EQUALS TO user_direction THEN
        assigne to priority 4


    FOR EACH elevator IN elevator_list

    IF elevatorfloor EQUALS user_floor AND elevator_stop THEN
        RETURN elevator

    ELSE IF elevator_floor IS higher TO user_floor AND elevator_stop THEN
        ADD elevator TO bestCase_list and Priority 1

    ELSE IF elevator_floor IS smaller TO user_floor AND elevator_stop THEN
        ADD TO bestCase_list elevator and Priority 1 

    ELSE IF elevator_floor IS smaller TO user_floor AND elevator_direction EQUALS user_direction THEN
        ADD TO bestCase_list elevator and Priority 2

    ELSE IF elevator_floor IS higher user_floor AND elevator_direction EQUALS user_direction THEN
        ADD TO bestCase_list elevator and Priority 2

    ELSE IF elevator_floor IS smaller TO user_floor AND elevator_direction EQUALS user_direction THEN
        RETURN elevator

    ELSE IF elevator_floor IS higher user_floor AND elevator_direction EQUALS user_direction THEN
        RETURN elevator

    ELSE IF elevator_floor IS smaller TO user_floor AND elevator_direction THEN   
        RETURN elevator

    ELSE IF 

    END FOR

    Compare bestCase_list 
ENDSEQUENCE


"step 3: button in elevator"
SEQUENCE input_elevator(floor, direction)
    FOR EACH time find_elevator() RETURN elevator 
    User from User_floor[i] go TO Storeys[i] AND INPUT Storeys[i]
    CALL Close_door()
    Elevator go TO INPUT Storeys[i]
    Open_door()
    ENDFOR
ENDSEQUENCE






